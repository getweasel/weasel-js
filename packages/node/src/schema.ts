/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-namespace */
// automatically generated by the FlatBuffers compiler, do not modify

export namespace touca.fbs {
  export enum Type {
    NONE = 0,
    Bool = 1,
    Int = 2,
    UInt = 3,
    Float = 4,
    Double = 5,
    String = 6,
    Object = 7,
    Array = 8
  }
}

export namespace touca.fbs {
  export enum ResultType {
    Check = 1,
    Assert = 2
  }
}

export namespace touca.fbs {
  export class TypeWrapper {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): TypeWrapper {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsTypeWrapper(
      bb: flatbuffers.ByteBuffer,
      obj?: TypeWrapper
    ): TypeWrapper {
      return (obj || new TypeWrapper()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    valueType(): touca.fbs.Type {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.readUint8(this.bb_pos + offset)
        : touca.fbs.Type.NONE;
    }

    value<T extends flatbuffers.Table>(obj: T): T | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
    }

    static startTypeWrapper(builder: flatbuffers.Builder): void {
      builder.startObject(2);
    }

    static addValueType(
      builder: flatbuffers.Builder,
      valueType: touca.fbs.Type
    ): void {
      builder.addFieldInt8(0, valueType, touca.fbs.Type.NONE);
    }

    static addValue(
      builder: flatbuffers.Builder,
      valueOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, valueOffset, 0);
    }

    static endTypeWrapper(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Bool {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Bool {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsBool(bb: flatbuffers.ByteBuffer, obj?: Bool): Bool {
      return (obj || new Bool()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): boolean {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
    }

    static startBool(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(builder: flatbuffers.Builder, value: boolean): void {
      builder.addFieldInt8(0, +value, +false);
    }

    static endBool(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Int {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Int {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsInt(bb: flatbuffers.ByteBuffer, obj?: Int): Int {
      return (obj || new Int()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): flatbuffers.Long {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.readInt64(this.bb_pos + offset)
        : this.bb!.createLong(0, 0);
    }

    static startInt(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(
      builder: flatbuffers.Builder,
      value: flatbuffers.Long
    ): void {
      builder.addFieldInt64(0, value, builder.createLong(0, 0));
    }

    static endInt(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class UInt {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): UInt {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsUInt(bb: flatbuffers.ByteBuffer, obj?: UInt): UInt {
      return (obj || new UInt()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): flatbuffers.Long {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.readUint64(this.bb_pos + offset)
        : this.bb!.createLong(0, 0);
    }

    static startUInt(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(
      builder: flatbuffers.Builder,
      value: flatbuffers.Long
    ): void {
      builder.addFieldInt64(0, value, builder.createLong(0, 0));
    }

    static endUInt(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Float {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Float {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsFloat(bb: flatbuffers.ByteBuffer, obj?: Float): Float {
      return (obj || new Float()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
    }

    static startFloat(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(builder: flatbuffers.Builder, value: number): void {
      builder.addFieldFloat32(0, value, 0.0);
    }

    static endFloat(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Double {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Double {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsDouble(bb: flatbuffers.ByteBuffer, obj?: Double): Double {
      return (obj || new Double()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
    }

    static startDouble(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(builder: flatbuffers.Builder, value: number): void {
      builder.addFieldFloat64(0, value, 0.0);
    }

    static endDouble(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class String {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): String {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsString(bb: flatbuffers.ByteBuffer, obj?: String): String {
      return (obj || new String()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    value(): string | null;
    value(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    value(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    static startString(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValue(
      builder: flatbuffers.Builder,
      valueOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, valueOffset, 0);
    }

    static endString(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class ObjectMember {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): ObjectMember {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsObjectMember(
      bb: flatbuffers.ByteBuffer,
      obj?: ObjectMember
    ): ObjectMember {
      return (obj || new ObjectMember()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    name(): string | null;
    name(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    name(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    value(obj?: touca.fbs.TypeWrapper): touca.fbs.TypeWrapper | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? (obj || new touca.fbs.TypeWrapper()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    static startObjectMember(builder: flatbuffers.Builder): void {
      builder.startObject(2);
    }

    static addName(
      builder: flatbuffers.Builder,
      nameOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, nameOffset, 0);
    }

    static addValue(
      builder: flatbuffers.Builder,
      valueOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, valueOffset, 0);
    }

    static endObjectMember(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Object {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Object {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsObject(bb: flatbuffers.ByteBuffer, obj?: Object): Object {
      return (obj || new Object()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    key(): string | null;
    key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    key(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    values(
      index: number,
      obj?: touca.fbs.ObjectMember
    ): touca.fbs.ObjectMember | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? (obj || new touca.fbs.ObjectMember()).__init(
            this.bb!.__indirect(
              this.bb!.__vector(this.bb_pos + offset) + index * 4
            ),
            this.bb!
          )
        : null;
    }

    valuesLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    static startObject(builder: flatbuffers.Builder): void {
      builder.startObject(2);
    }

    static addKey(
      builder: flatbuffers.Builder,
      keyOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, keyOffset, 0);
    }

    static addValues(
      builder: flatbuffers.Builder,
      valuesOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, valuesOffset, 0);
    }

    static createValuesVector(
      builder: flatbuffers.Builder,
      data: flatbuffers.Offset[]
    ): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }

    static startValuesVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(4, numElems, 4);
    }

    static endObject(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Array {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Array {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsArray(bb: flatbuffers.ByteBuffer, obj?: Array): Array {
      return (obj || new Array()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    values(
      index: number,
      obj?: touca.fbs.TypeWrapper
    ): touca.fbs.TypeWrapper | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? (obj || new touca.fbs.TypeWrapper()).__init(
            this.bb!.__indirect(
              this.bb!.__vector(this.bb_pos + offset) + index * 4
            ),
            this.bb!
          )
        : null;
    }

    valuesLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    static startArray(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addValues(
      builder: flatbuffers.Builder,
      valuesOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, valuesOffset, 0);
    }

    static createValuesVector(
      builder: flatbuffers.Builder,
      data: flatbuffers.Offset[]
    ): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }

    static startValuesVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(4, numElems, 4);
    }

    static endArray(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Result {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Result {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsResult(bb: flatbuffers.ByteBuffer, obj?: Result): Result {
      return (obj || new Result()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    key(): string | null;
    key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    key(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    value(obj?: touca.fbs.TypeWrapper): touca.fbs.TypeWrapper | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? (obj || new touca.fbs.TypeWrapper()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    typ(): touca.fbs.ResultType {
      const offset = this.bb!.__offset(this.bb_pos, 8);
      return offset
        ? this.bb!.readUint8(this.bb_pos + offset)
        : touca.fbs.ResultType.Check;
    }

    static startResult(builder: flatbuffers.Builder): void {
      builder.startObject(3);
    }

    static addKey(
      builder: flatbuffers.Builder,
      keyOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, keyOffset, 0);
    }

    static addValue(
      builder: flatbuffers.Builder,
      valueOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, valueOffset, 0);
    }

    static addTyp(
      builder: flatbuffers.Builder,
      typ: touca.fbs.ResultType
    ): void {
      builder.addFieldInt8(2, typ, touca.fbs.ResultType.Check);
    }

    static endResult(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Assertion {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Assertion {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsAssertion(
      bb: flatbuffers.ByteBuffer,
      obj?: Assertion
    ): Assertion {
      return (obj || new Assertion()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    static startAssertion(builder: flatbuffers.Builder): void {
      builder.startObject(2);
    }

    static endAssertion(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Metric {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Metric {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMetric(bb: flatbuffers.ByteBuffer, obj?: Metric): Metric {
      return (obj || new Metric()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    key(): string | null;
    key(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    key(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    value(obj?: touca.fbs.TypeWrapper): touca.fbs.TypeWrapper | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? (obj || new touca.fbs.TypeWrapper()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    static startMetric(builder: flatbuffers.Builder): void {
      builder.startObject(2);
    }

    static addKey(
      builder: flatbuffers.Builder,
      keyOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, keyOffset, 0);
    }

    static addValue(
      builder: flatbuffers.Builder,
      valueOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, valueOffset, 0);
    }

    static endMetric(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Results {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Results {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsResults(
      bb: flatbuffers.ByteBuffer,
      obj?: Results
    ): Results {
      return (obj || new Results()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    entries(index: number, obj?: touca.fbs.Result): touca.fbs.Result | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? (obj || new touca.fbs.Result()).__init(
            this.bb!.__indirect(
              this.bb!.__vector(this.bb_pos + offset) + index * 4
            ),
            this.bb!
          )
        : null;
    }

    entriesLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    static startResults(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addEntries(
      builder: flatbuffers.Builder,
      entriesOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, entriesOffset, 0);
    }

    static createEntriesVector(
      builder: flatbuffers.Builder,
      data: flatbuffers.Offset[]
    ): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }

    static startEntriesVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(4, numElems, 4);
    }

    static endResults(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Assertions {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Assertions {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsAssertions(
      bb: flatbuffers.ByteBuffer,
      obj?: Assertions
    ): Assertions {
      return (obj || new Assertions()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    static startAssertions(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static endAssertions(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Metrics {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Metrics {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMetrics(
      bb: flatbuffers.ByteBuffer,
      obj?: Metrics
    ): Metrics {
      return (obj || new Metrics()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    entries(index: number, obj?: touca.fbs.Metric): touca.fbs.Metric | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? (obj || new touca.fbs.Metric()).__init(
            this.bb!.__indirect(
              this.bb!.__vector(this.bb_pos + offset) + index * 4
            ),
            this.bb!
          )
        : null;
    }

    entriesLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    static startMetrics(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addEntries(
      builder: flatbuffers.Builder,
      entriesOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, entriesOffset, 0);
    }

    static createEntriesVector(
      builder: flatbuffers.Builder,
      data: flatbuffers.Offset[]
    ): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }

    static startEntriesVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(4, numElems, 4);
    }

    static endMetrics(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Metadata {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Metadata {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMetadata(
      bb: flatbuffers.ByteBuffer,
      obj?: Metadata
    ): Metadata {
      return (obj || new Metadata()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    testsuite(): string | null;
    testsuite(
      optionalEncoding: flatbuffers.Encoding
    ): string | Uint8Array | null;
    testsuite(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    version(): string | null;
    version(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    version(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    testcase(): string | null;
    testcase(
      optionalEncoding: flatbuffers.Encoding
    ): string | Uint8Array | null;
    testcase(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 10);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    builtAt(): string | null;
    builtAt(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    builtAt(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 12);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    teamslug(): string | null;
    teamslug(
      optionalEncoding: flatbuffers.Encoding
    ): string | Uint8Array | null;
    teamslug(optionalEncoding?: any): string | Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 14);
      return offset
        ? this.bb!.__string(this.bb_pos + offset, optionalEncoding)
        : null;
    }

    static startMetadata(builder: flatbuffers.Builder): void {
      builder.startObject(6);
    }

    static addTestsuite(
      builder: flatbuffers.Builder,
      testsuiteOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, testsuiteOffset, 0);
    }

    static addVersion(
      builder: flatbuffers.Builder,
      versionOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, versionOffset, 0);
    }

    static addTestcase(
      builder: flatbuffers.Builder,
      testcaseOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(3, testcaseOffset, 0);
    }

    static addBuiltAt(
      builder: flatbuffers.Builder,
      builtAtOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(4, builtAtOffset, 0);
    }

    static addTeamslug(
      builder: flatbuffers.Builder,
      teamslugOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(5, teamslugOffset, 0);
    }

    static endMetadata(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Message {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Message {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMessage(
      bb: flatbuffers.ByteBuffer,
      obj?: Message
    ): Message {
      return (obj || new Message()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    metadata(obj?: touca.fbs.Metadata): touca.fbs.Metadata | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? (obj || new touca.fbs.Metadata()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    results(obj?: touca.fbs.Results): touca.fbs.Results | null {
      const offset = this.bb!.__offset(this.bb_pos, 6);
      return offset
        ? (obj || new touca.fbs.Results()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    metrics(obj?: touca.fbs.Metrics): touca.fbs.Metrics | null {
      const offset = this.bb!.__offset(this.bb_pos, 10);
      return offset
        ? (obj || new touca.fbs.Metrics()).__init(
            this.bb!.__indirect(this.bb_pos + offset),
            this.bb!
          )
        : null;
    }

    static startMessage(builder: flatbuffers.Builder): void {
      builder.startObject(4);
    }

    static addMetadata(
      builder: flatbuffers.Builder,
      metadataOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, metadataOffset, 0);
    }

    static addResults(
      builder: flatbuffers.Builder,
      resultsOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(1, resultsOffset, 0);
    }

    static addMetrics(
      builder: flatbuffers.Builder,
      metricsOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(3, metricsOffset, 0);
    }

    static endMessage(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class MessageBuffer {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): MessageBuffer {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMessageBuffer(
      bb: flatbuffers.ByteBuffer,
      obj?: MessageBuffer
    ): MessageBuffer {
      return (obj || new MessageBuffer()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    buf(index: number): number | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index)
        : 0;
    }

    bufLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    bufArray(): Uint8Array | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? new Uint8Array(
            this.bb!.bytes().buffer,
            this.bb!.bytes().byteOffset +
              this.bb!.__vector(this.bb_pos + offset),
            this.bb!.__vector_len(this.bb_pos + offset)
          )
        : null;
    }

    static startMessageBuffer(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addBuf(
      builder: flatbuffers.Builder,
      bufOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, bufOffset, 0);
    }

    static createBufVector(
      builder: flatbuffers.Builder,
      data: number[] | Uint8Array
    ): flatbuffers.Offset {
      builder.startVector(1, data.length, 1);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt8(data[i]);
      }
      return builder.endVector();
    }

    static startBufVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(1, numElems, 1);
    }

    static endMessageBuffer(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }
  }
}

export namespace touca.fbs {
  export class Messages {
    bb: flatbuffers.ByteBuffer | null = null;

    bb_pos = 0;

    __init(i: number, bb: flatbuffers.ByteBuffer): Messages {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }

    static getRootAsMessages(
      bb: flatbuffers.ByteBuffer,
      obj?: Messages
    ): Messages {
      return (obj || new Messages()).__init(
        bb.readInt32(bb.position()) + bb.position(),
        bb
      );
    }

    messages(
      index: number,
      obj?: touca.fbs.MessageBuffer
    ): touca.fbs.MessageBuffer | null {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset
        ? (obj || new touca.fbs.MessageBuffer()).__init(
            this.bb!.__indirect(
              this.bb!.__vector(this.bb_pos + offset) + index * 4
            ),
            this.bb!
          )
        : null;
    }

    messagesLength(): number {
      const offset = this.bb!.__offset(this.bb_pos, 4);
      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
    }

    static startMessages(builder: flatbuffers.Builder): void {
      builder.startObject(1);
    }

    static addMessages(
      builder: flatbuffers.Builder,
      messagesOffset: flatbuffers.Offset
    ): void {
      builder.addFieldOffset(0, messagesOffset, 0);
    }

    static createMessagesVector(
      builder: flatbuffers.Builder,
      data: flatbuffers.Offset[]
    ): flatbuffers.Offset {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }

    static startMessagesVector(
      builder: flatbuffers.Builder,
      numElems: number
    ): void {
      builder.startVector(4, numElems, 4);
    }

    static endMessages(builder: flatbuffers.Builder): flatbuffers.Offset {
      const offset = builder.endObject();
      return offset;
    }

    static finishMessagesBuffer(
      builder: flatbuffers.Builder,
      offset: flatbuffers.Offset
    ): void {
      builder.finish(offset);
    }
  }
}
